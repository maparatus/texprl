import { RuntimeError } from "../errors";
import { generateValidatedOperators } from "../runtime-helpers";

/**
 * These are generated by non function syntax in the language.
 */
const langOperators = [
  {
    name: "literal",
    handler: (v) => v,
  },
  {
    name: "array",
    handler: (...v) => v,
  },
  {
    name: "+",
    handler: (a, b) => (a + b),
    args: {
      length: 2,
      binaryExpression: true,
      def: ["number", "number"],
    },
  },
  {
    name: "-",
    handler: (a, b) => (a - b),
    args: {
      length: 2,
      binaryExpression: true,
      def: ["number", "number"],
    },
  },
  {
    name: "*",
    handler: (a, b) => a * b,
    args: {
      length: 2,
      binaryExpression: true,
      def: ["number", "number"],
    },
  },
  {
    name: "/",
    handler: (a, b) => a / b,
    args: {
      length: 2,
      binaryExpression: true,
      def: ["number", "number"],
    },
  },
];

/**
 * There operators are for named functions, you can add anything you like here.
 */
const operators = generateValidatedOperators([
  ...langOperators,
  {
    name: "pow",
    args: {
      length: 2,
      def: ["number", "number"],
    },
    handler: function (a, b) {
      return Math.pow(a, b);
    },
  },
  {
    name: "at",
    args: {
      length: 2,
      def: ["number", "array"],
    },
    handler: function (index, arr) {
      return arr.at(index);
    },
  },
  {
    name: "equals",
    handler: (a, b) => a === b,
  },
  {
    name: "not_equals",
    handler: (a, b) => a !== b,
  },
  {
    name: "all",
    handler: (...v) => v.every(Boolean),
  },
  {
    name: "any",
    handler: (...v) => !!v.find(Boolean),
  },
  {
    name: "none",
    handler: (...v) => !v.find(Boolean),
  },
]);

function _call(arr, errors, path = [0]) {
  if (Array.isArray(arr)) {
    const [op] = arr;
    const args = arr.slice(1);

    if (operators[op]) {
      const argsToPass = args.map((i, index) =>
        _call(i, errors, path.concat(index))
      );
      try {
        return operators[op].apply({path}, argsToPass);
      }
      catch(err) {
        errors.push(err);
      }
    } else {
      // TODO: This should throw errors with positional info.
      errors.push(
        new RuntimeError(`No such function: ${op}`, {
          path,
        })
      );
    }
  } else {
    return arr;
  }
}

export default function call(arr) {
  const errors = [];
  return {
    output: _call(arr, errors),
    errors,
  };
}
