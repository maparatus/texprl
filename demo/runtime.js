import { RuntimeError } from "../errors";

/**
 * These are generated by non function syntax in the language.
 */
const langOperators = {
  literal: (v) => v,
  array: (...v) => v,
  "+": (a, b) => a + b,
  "-": (a, b) => a - b,
  "*": (a, b) => a * b,
  "/": (a, b) => a / b,
};

/**
 * There operators are for named functions, you can add anything you like here.
 */
const operators = {
  ...langOperators,
  pow: (a, b) => {
    let errAt;
    if (!Number.isNumber(a)) errAt = 0;
    if (!Number.isNumber(b)) errAt = 1;
    if (errAt) {
      throw new RuntimeError("Argument must be Number", {
        path: this.path.concat(errAt),
      })
    }
    return Math.pow(a, b);
  },
  at: function (index, arr) {
    if (!Array.isArray(arr)) {
      // TODO: Should throw error at argument path.
      throw new RuntimeError("Argument must be array", {
        path: this.path.concat(1)
      });
    }
    return arr.at(index);
  },
  equals: (a, b) => a === b,
  not_equals: (a, b) => a !== b,
  all: (...v) => v.every(Boolean),
  any: (...v) => !!v.find(Boolean),
  none: (...v) => !v.find(Boolean),
};

function _call(arr, errors, path = [0]) {
  if (Array.isArray(arr)) {
    const [op] = arr;
    const args = arr.slice(1);

    if (operators[op]) {
      const argsToPass = args.map((i, index) =>
        _call(i, errors, path.concat(index))
      );
      try {
        return operators[op].apply({path}, argsToPass);
      }
      catch(err) {
        errors.push(err);
      }
    } else {
      // TODO: This should throw errors with positional info.
      errors.push(
        new RuntimeError(`No such function: ${op}`, {
          path,
        })
      );
    }
  } else {
    return arr;
  }
}

export default function call(arr) {
  const errors = [];
  return {
    output: _call(arr, errors),
    errors,
  };
}
