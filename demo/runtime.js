import { RuntimeError } from "../errors";

/**
 * These are generated by non function syntax in the language.
 */
const langOperators = [
  {
    name: "literal",
    handler: (v) => v
  },
  {
    name: "array",
    handler: (...v) => v,
  },
  {
    name: "+",
    handler: (a, b) => (a + b),
  },
  {
    name: "-",
    handler: (a, b) => (a - b),
  },
  {
    name: "*",
    handler: (a, b) => a * b
  },
  {
    name: "/",
    handler: (a, b) => a / b,
  },
];

function checkArgs (def, args, context) {
  if (!def.args) {
    return;
  }

  // Check number of arguments...
  if (def.args.length && args.length !== def.args.length) {
    throw new RuntimeError(`'pow' expects 2 args, found ${args.length}`, {
      path: context.path,
    });
  }

  // Check types of arguments...
  if (def.args.def) {
    const errAt = def.args.def.findIndex((t, idx) => {
      if (t === "*") {
        return false;
      }
      if (t === "Array") {
        return !Array.isArray(args[idx]);
      }
      return typeof(args[idx]) !== t;
    })

    if (errAt > -1) {
      throw new RuntimeError(`Argument ${errAt} must be ${def.args.def[errAt]}`, {
        path: context.path.concat(errAt),
      })
    }
  }
}

function generateOperators (ops=[]) {
  const out = {};
  ops.forEach(op => {
    out[op.name] = function (...args) {
      checkArgs(op, args, this);
      return op.handler.apply(this, args);
    };
  });
  return out;
}

/**
 * There operators are for named functions, you can add anything you like here.
 */
const operators = generateOperators([
  ...langOperators,
  {
    name: "pow",
    args: {
      length: 2,
      def: ["number", "number"],
    },
    handler: function (a, b) {
      return Math.pow(a, b);
    },
  },
  {
    name: "at",
    args: {
      length: 2,
      def: ["number", "array"],
    },
    handler: function (index, arr) {
      return arr.at(index);
    },
  },
  {
    name: "equals",
    handler: (a, b) => a === b,
  },
  {
    name: "not_equals",
    handler: (a, b) => a !== b,
  },
  {
    name: "all",
    handler: (...v) => v.every(Boolean),
  },
  {
    name: "any",
    handler: (...v) => !!v.find(Boolean),
  },
  {
    name: "none",
    handler: (...v) => !v.find(Boolean),
  },
]);

function _call(arr, errors, path = [0]) {
  if (Array.isArray(arr)) {
    const [op] = arr;
    const args = arr.slice(1);

    if (operators[op]) {
      const argsToPass = args.map((i, index) =>
        _call(i, errors, path.concat(index))
      );
      try {
        return operators[op].apply({path}, argsToPass);
      }
      catch(err) {
        errors.push(err);
      }
    } else {
      // TODO: This should throw errors with positional info.
      errors.push(
        new RuntimeError(`No such function: ${op}`, {
          path,
        })
      );
    }
  } else {
    return arr;
  }
}

export default function call(arr) {
  const errors = [];
  return {
    output: _call(arr, errors),
    errors,
  };
}
